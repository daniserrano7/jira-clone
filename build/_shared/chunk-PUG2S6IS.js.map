{
  "version": 3,
  "sources": ["../../../src/app/store/theme.store.tsx"],
  "sourcesContent": ["import {\n  createContext,\n  useContext,\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n} from \"react\";\nimport { useFetcher } from \"@remix-run/react\";\n\n// Inspired from Kent C. Dodds repo https://github.com/kentcdodds/kentcdodds.com/blob/main/app/utils/theme-provider.tsx\nexport enum Theme {\n  LIGHT = \"light\",\n  DARK = \"dark\",\n  LAVA = \"lava\",\n  LIME = \"lime\",\n}\nexport const themes: Array<Theme> = Object.values(Theme);\nexport enum Preference {\n  SELECTED = \"selected\",\n  SYSTEM = \"system\",\n}\nconst preferences: Array<Preference> = Object.values(Preference);\n\nexport const DEFAULT_THEME: Theme = Theme.LIGHT;\nconst DEFAULT_PREFERENCE: Preference = Preference.SYSTEM;\n\ntype ThemeContextType = {\n  theme: Theme | null;\n  preference: Preference | null;\n  setTheme: (theme: Theme, preference?: Preference) => void;\n};\n\nconst ThemeContext = createContext<ThemeContextType | null>(null);\n\nconst prefersLightMQ = \"(prefers-color-scheme: light)\";\nexport const getSystemTheme = (): Theme =>\n  window.matchMedia(prefersLightMQ).matches ? Theme.LIGHT : Theme.DARK;\n\nexport const ThemeProvider = ({\n  children,\n  specifiedTheme,\n  specifiedPreference,\n}: ThemeProviderProps) => {\n  const [theme, setThemeState] = useState<Theme | null>(() => {\n    // On the server, if we don't have a specified theme then we should\n    // return null and the clientThemeCode will set the theme for us\n    // before hydration. Then (during hydration), this code will get the same\n    // value that clientThemeCode got so hydration is happy.\n    if (specifiedTheme) {\n      if (themes.includes(specifiedTheme)) return specifiedTheme;\n      else return null;\n    }\n\n    // there's no way for us to know what the theme should be in this context\n    // the client will have to figure it out before hydration.\n    if (typeof window !== \"object\") return null;\n\n    return getSystemTheme();\n  });\n  const [preference, setPreference] = useState<Preference | null>(() => {\n    if (isValidPreference(specifiedPreference)) return specifiedPreference;\n\n    return DEFAULT_PREFERENCE;\n  });\n\n  const persistTheme = useFetcher();\n  const persistThemeRef = useRef(persistTheme);\n  useEffect(() => {\n    persistThemeRef.current = persistTheme;\n  }, [persistTheme]);\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(prefersLightMQ);\n\n    const handleChange = () => {\n      if (preference !== Preference.SYSTEM) return;\n\n      const newTheme = mediaQuery.matches ? Theme.LIGHT : Theme.DARK;\n      setThemeState(newTheme);\n    };\n    mediaQuery.addEventListener(\"change\", handleChange);\n    return () => mediaQuery.removeEventListener(\"change\", handleChange);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [preference]);\n\n  const setTheme = useCallback(\n    (newTheme: Theme, newPreference: Preference = Preference.SYSTEM) => {\n      persistThemeRef.current.submit(\n        { theme: newTheme, preference: newPreference },\n        { action: \"action/set-theme\", method: \"post\" }\n      );\n      setThemeState(newTheme);\n      setPreference(newPreference);\n    },\n    []\n  );\n\n  const value = {\n    theme,\n    preference,\n    setTheme,\n  };\n  return (\n    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>\n  );\n};\n\ninterface ThemeProviderProps {\n  children: JSX.Element;\n  specifiedTheme: Theme | undefined;\n  specifiedPreference: Preference | undefined;\n}\n\nexport const useTheme = () => {\n  const themeContext = useContext(ThemeContext);\n  if (themeContext === null) {\n    throw new Error(\"useTheme must be used within a ThemeProvider\");\n  }\n  return themeContext;\n};\n\nexport const isValidTheme = (theme: unknown): theme is Theme => {\n  return themes.includes(theme as Theme);\n};\n\nexport const isValidPreference = (\n  preference: unknown\n): preference is Preference => {\n  return preferences.includes(preference as Preference);\n};\n"],
  "mappings": ";;;;;;;;;;;;AAAA,mBAOO;AAiGH;AA7FG,IAAK,QAAL,kBAAKA,WAAL;AACL,EAAAA,OAAA,WAAQ;AACR,EAAAA,OAAA,UAAO;AACP,EAAAA,OAAA,UAAO;AACP,EAAAA,OAAA,UAAO;AAJG,SAAAA;AAAA,GAAA;AAML,IAAM,SAAuB,OAAO,OAAO,KAAK;AAChD,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,YAAA,cAAW;AACX,EAAAA,YAAA,YAAS;AAFC,SAAAA;AAAA,GAAA;AAIZ,IAAM,cAAiC,OAAO,OAAO,UAAU;AAExD,IAAM,gBAAuB;AACpC,IAAM,qBAAiC;AAQvC,IAAM,mBAAe,4BAAuC,IAAI;AAEhE,IAAM,iBAAiB;AAChB,IAAM,iBAAiB,MAC5B,OAAO,WAAW,cAAc,EAAE,UAAU,sBAAc;AAErD,IAAM,gBAAgB,CAAC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AACF,MAA0B;AACxB,QAAM,CAAC,OAAO,aAAa,QAAI,uBAAuB,MAAM;AAK1D,QAAI,gBAAgB;AAClB,UAAI,OAAO,SAAS,cAAc;AAAG,eAAO;AAAA;AACvC,eAAO;AAAA,IACd;AAIA,QAAI,OAAO,WAAW;AAAU,aAAO;AAEvC,WAAO,eAAe;AAAA,EACxB,CAAC;AACD,QAAM,CAAC,YAAY,aAAa,QAAI,uBAA4B,MAAM;AACpE,QAAI,kBAAkB,mBAAmB;AAAG,aAAO;AAEnD,WAAO;AAAA,EACT,CAAC;AAED,QAAM,eAAe,WAAW;AAChC,QAAM,sBAAkB,qBAAO,YAAY;AAC3C,8BAAU,MAAM;AACd,oBAAgB,UAAU;AAAA,EAC5B,GAAG,CAAC,YAAY,CAAC;AAEjB,8BAAU,MAAM;AACd,UAAM,aAAa,OAAO,WAAW,cAAc;AAEnD,UAAM,eAAe,MAAM;AACzB,UAAI,eAAe;AAAmB;AAEtC,YAAM,WAAW,WAAW,UAAU,sBAAc;AACpD,oBAAc,QAAQ;AAAA,IACxB;AACA,eAAW,iBAAiB,UAAU,YAAY;AAClD,WAAO,MAAM,WAAW,oBAAoB,UAAU,YAAY;AAAA,EAEpE,GAAG,CAAC,UAAU,CAAC;AAEf,QAAM,eAAW;AAAA,IACf,CAAC,UAAiB,gBAA4B,0BAAsB;AAClE,sBAAgB,QAAQ;AAAA,QACtB,EAAE,OAAO,UAAU,YAAY,cAAc;AAAA,QAC7C,EAAE,QAAQ,oBAAoB,QAAQ,OAAO;AAAA,MAC/C;AACA,oBAAc,QAAQ;AACtB,oBAAc,aAAa;AAAA,IAC7B;AAAA,IACA,CAAC;AAAA,EACH;AAEA,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SACE,mDAAC,aAAa,UAAb,EAAsB,OAAe,YAAtC;AAAA;AAAA;AAAA;AAAA,SAA+C;AAEnD;AAQO,IAAM,WAAW,MAAM;AAC5B,QAAM,mBAAe,yBAAW,YAAY;AAC5C,MAAI,iBAAiB,MAAM;AACzB,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AACA,SAAO;AACT;AAEO,IAAM,eAAe,CAAC,UAAmC;AAC9D,SAAO,OAAO,SAAS,KAAc;AACvC;AAEO,IAAM,oBAAoB,CAC/B,eAC6B;AAC7B,SAAO,YAAY,SAAS,UAAwB;AACtD;",
  "names": ["Theme", "Preference"]
}
